# -*- coding: utf-8 -*-
"""Another copy of Untitled4.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/13-yAII7hv4urXNHf37yR_hSkpemReTG3
"""

import pandas as pd
import matplotlib.pyplot as plt
import numpy as np
from statsmodels.tsa.stattools import adfuller
from statsmodels.graphics.tsaplots import plot_acf, plot_pacf
from statsmodels.tsa.arima.model import ARIMA
from sklearn.metrics import mean_absolute_error, mean_squared_error, r2_score
from sklearn.preprocessing import LabelEncoder
from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestRegressor
from sklearn.linear_model import LinearRegression
from sklearn.tree import DecisionTreeRegressor
import seaborn as sns

# Load the dataset
try:
    df = pd.read_csv('/content/masked_kiva_loans.csv')
    print("Dataset loaded successfully.")
except FileNotFoundError:
    print("Error: '/content/masked_kiva_loans.csv' not found.")
    df = None

if df is not None:
    # Show missing values
    print(df.isnull().sum())

   # Handle missing values
    df.dropna(subset=['partner_id', 'borrower_genders'], inplace=True)

    # Drop rows where 'funded_amount' is 0
    df = df[df['funded_amount'] > 0].copy()
    print(f"Number of rows after dropping 0 funded amounts: {len(df)}")

    print(f"\nNumber of duplicates: {df.duplicated().sum()}")

    # Replace borrower_genders values containing both male and female with "mixed"
    def replace_mixed_genders(gender_str):
        gender_str = str(gender_str).lower()
        if 'female' in gender_str and 'male' in gender_str:
            return 'mixed'
        return gender_str

    df['borrower_genders'] = df['borrower_genders'].apply(replace_mixed_genders)
    print("Values in 'borrower_genders' containing both male and female replaced with 'mixed'.")

    # Outlier treatment for funded_amount
    Q1_funded = df['funded_amount'].quantile(0.25)
    Q3_funded = df['funded_amount'].quantile(0.75)
    IQR_funded = Q3_funded - Q1_funded
    lower_bound_funded = Q1_funded - 1.5 * IQR_funded
    upper_bound_funded = Q3_funded + 1.5 * IQR_funded
    df = df[df['funded_amount'].between(lower_bound_funded, upper_bound_funded)]

    # Outlier treatment for loan_amount
    Q1_loan = df['loan_amount'].quantile(0.25)
    Q3_loan = df['loan_amount'].quantile(0.75)
    IQR_loan = Q3_loan - Q1_loan
    lower_bound_loan = Q1_loan - 1.5 * IQR_loan
    upper_bound_loan = Q3_loan + 1.5 * IQR_loan
    df = df[df['loan_amount'].between(lower_bound_loan, upper_bound_loan)]

    # Count genders
    df['nfemales'] = df['borrower_genders'].str.lower().str.count('female')
    df['nmales'] = df['borrower_genders'].str.lower().str.count('male') - df['nfemales']

    # Categorize gender into simplified types
    def categorize_gender(gender_str):
        gender_str = str(gender_str).lower()
        if gender_str == 'mixed':
            return 'mixed'
        elif 'female' in gender_str and 'male' not in gender_str:
            return 'female'
        elif 'male' in gender_str and 'female' not in gender_str:
            return 'male'
        else:
            return 'unknown'

    df['gender_category'] = df['borrower_genders'].apply(categorize_gender)

    # Bar plot of gender categories
    plt.figure(figsize=(10, 8))
    gender_counts = df['gender_category'].value_counts()
    sns.barplot(x=gender_counts.values, y=gender_counts.index)
    for i, v in enumerate(gender_counts.values):
        plt.text(v + 5, i, str(v), color='black', fontweight='bold', va='center')
    plt.title('Distribution of Loans by Borrower Gender')
    plt.xlabel('Number of Loans')
    plt.ylabel('Gender Category')
    plt.tight_layout()
    plt.savefig('gender_distribution.png')
    plt.close()

    # Convert categorical columns
    df['partner_id'] = df['partner_id'].astype('category')
    df['sector'] = df['sector'].astype('category')
    df['country'] = df['country'].astype('category')
    df['repayment_interval'] = df['repayment_interval'].astype('category')

    # Save cleaned dataset
    df.to_csv('kiva_loans_cleaned2.csv', index=False)

    print("\nDataFrame Info after cleaning steps:")
    df.info()

    print("\nMissing values after cleaning:")
    print(df.isnull().sum())



from google.colab import files

# Save the DataFrame to a CSV file
df.to_csv('df.csv' ,index=False)


# Download the file
files.download('df.csv')



df.to_csv('kiva_loans_cleaned2.csv', index=False)

# Histograms for numerical features يرسم منحنى الكثافة (Kernel Density Estimate) لتوضيح الشكل العام للتوزيع.

plt.figure(figsize=(15, 10))
plt.subplot(2, 2, 1)
sns.histplot(df['funded_amount'], kde=True)
plt.title('Funded Amount Distribution')
##############


plt.subplot(2, 2, 2)
sns.histplot(df['loan_amount'], kde=True)
plt.title('Loan Amount Distribution')
############################



plt.subplot(2, 2, 3)
sns.histplot(df['term_in_months'], kde=True)
plt.title('Term in Months Distribution')
#############################
plt.show()


plt.subplot(2, 2, 4)
sns.histplot(df['lender_count'], kde=True)
plt.title('Lender Count Distribution')
plt.tight_layout()
plt.show()
#################
plt.figure(figsize=(15, 5))
plt.subplot(1, 2, 1)
df['sector'].value_counts().plot(kind='bar')
plt.title('Loan Sector Distribution')
plt.xticks(rotation=45, ha='right')
###############################


plt.subplot(1, 2, 2)
df['country'].value_counts().head(10).plot(kind='bar') # Top 10 countries
plt.title('Top 10 Countries')
plt.xticks(rotation=45, ha='right')

plt.tight_layout()
plt.show()
############################
# Scatter plot: Lender Count vs. Funded Amount


plt.figure(figsize=(8, 6))
sns.scatterplot(x='lender_count', y='funded_amount', data=df)
plt.title('Lender Count vs. Funded Amount')
plt.show()



















# Calculate descriptive statistics
print("Descriptive Statistics for Funded Amount:")
print(df['funded_amount'].describe())
print("\nDescriptive Statistics for Lender Count:")
print(df['lender_count'].describe())





























# Visualize distributions
plt.figure(figsize=(12, 6))

plt.subplot(2, 2, 1)
sns.histplot(df['funded_amount'], kde=True)
plt.title('Distribution of Funded Amount')

plt.subplot(2, 2, 2)
sns.boxplot(y=df['funded_amount'])
plt.title('Box Plot of Funded Amount')

plt.subplot(2, 2, 3)
sns.histplot(df['lender_count'], kde=True)
plt.title('Distribution of Lender Count')

plt.subplot(2, 2, 4)
sns.boxplot(y=df['lender_count'])
plt.title('Box Plot of Lender Count')

plt.tight_layout()
plt.show()


# Observations about the distributions, including skewness, outliers, ranges, and frequencies.






















# Calculate Pearson correlation
pearson_corr = df['funded_amount'].corr(df['lender_count'])

# Calculate Spearman's rank correlation
spearman_corr = df['funded_amount'].corr(df['lender_count'], method='spearman')


























# Calculate descriptive statistics
funded_amount_stats = df['funded_amount'].describe()
lender_count_stats = df['lender_count'].describe()












# Print and document the results
print(f"Pearson correlation coefficient: {pearson_corr}")
print(f"Spearman's rank correlation coefficient: {spearman_corr}")
print("\nDescriptive Statistics for Funded Amount:")
print(funded_amount_stats)
print("\nDescriptive Statistics for Lender Count:")
print(lender_count_stats)

# Correlation Visualization: Lender Count vs. Funded Amount
plt.figure(figsize=(10, 6))
sns.regplot(x='lender_count', y='funded_amount', data=df, line_kws={"color": "red"})
plt.title('Correlation between Lender Count and Funded Amount')
plt.xlabel('Lender Count')
plt.ylabel('Funded Amount')
plt.show()



























# Distribution Visualizations: Histograms with KDEs
plt.figure(figsize=(12, 8))
plt.subplot(2, 2, 1)
sns.histplot(df['funded_amount'], kde=True, color='skyblue')
plt.title('Funded Amount Distribution')
plt.subplot(2, 2, 2)
sns.histplot(df['loan_amount'], kde=True, color='salmon')
plt.title('Loan Amount Distribution')
plt.subplot(2, 2, 3)
sns.histplot(df['lender_count'], kde=True, color='lightgreen')
plt.title('Lender Count Distribution')
plt.subplot(2, 2, 4)
sns.histplot(df['term_in_months'], kde=True, color='gold')
plt.title('Term in Months Distribution')
plt.tight_layout()
plt.show()

# Categorical Variable Visualizations: Bar Charts
plt.figure(figsize=(14, 6))
plt.subplot(1, 2, 1)
sector_counts = df['sector'].value_counts()
sns.barplot(x=sector_counts.index, y=sector_counts.values, palette='viridis')
plt.title('Distribution of Loan Sectors')
plt.xticks(rotation=45, ha='right')
plt.subplot(1, 2, 2)
top_countries = df['country'].value_counts().head(10)
sns.barplot(x=top_countries.index, y=top_countries.values, palette='magma')
plt.title('Top 10 Countries with Most Loans')
plt.xticks(rotation=45, ha='right')
plt.tight_layout()
plt.show()

# Additional Visualizations: Box Plots and Scatter Plot
plt.figure(figsize=(14, 6))
plt.subplot(1, 2, 1)
sns.boxplot(x='sector', y='funded_amount', data=df, palette='Set3')
plt.title('Funded Amount by Sector')
plt.xticks(rotation=45, ha='right')
plt.subplot(1,2,2)
sns.scatterplot(x='loan_amount', y='funded_amount', data=df, hue='sector', palette='deep')
plt.title('Loan Amount vs Funded Amount')
plt.tight_layout()
plt.show()

df = pd.read_csv('kiva_loans_cleaned2.csv')
print("Dataset loaded successfully.")

le = LabelEncoder()
df['sector_encoded'] = le.fit_transform(df['sector'])
df['country_encoded'] = le.fit_transform(df['country'])
df['repayment_interval_encoded'] = le.fit_transform(df['repayment_interval'])

# Define features and target for prediction
# Features selected based on relevance to funded_amount
features = ['loan_amount', 'term_in_months', 'lender_count', 'sector_encoded', 'country_encoded', 'repayment_interval_encoded']
X = df[features]
y = df['funded_amount']

# Split data into training and testing sets
# 80% train, 20% test for robust evaluation
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Train Random Forest Regressor model
# Random Forest is chosen for its ability to handle non-linear relationships and feature interactions
rf_model = RandomForestRegressor(n_estimators=100, random_state=42)
rf_model.fit(X_train, y_train)

# Predict on test set and evaluate model performance
y_pred = rf_model.predict(X_test)
mse = mean_squared_error(y_test, y_pred)
r2 = r2_score(y_test, y_pred)
print(f"Mean Squared Error: {mse:.2f}")
print(f"R-squared Score: {r2:.2f}")

# Visualize feature importance to understand key predictors
feature_importance = pd.Series(rf_model.feature_importances_, index=features).sort_values(ascending=False)
plt.figure(figsize=(8, 6))
feature_importance.plot(kind='bar')
plt.title('Feature Importance in Predicting Funded Amount')
plt.xlabel('Features')
plt.ylabel('Importance')
plt.tight_layout()
plt.savefig('feature_importance.png')  # Save for presentation
plt.close()

# Print key results for presentation
print("\nKey Results for Presentation:")
print(f"1. Model Performance: R-squared = {r2:.2f}, MSE = {mse:.2f}")
print(f"2. Top Feature: {feature_importance.index[0]} with importance {feature_importance.iloc[0]:.3f}")
print("3. Feature importance plot saved as 'feature_importance.png'")
# Encode categorical variables for model input
le = LabelEncoder()
df['sector_encoded'] = le.fit_transform(df['sector'])
df['country_encoded'] = le.fit_transform(df['country'])
df['repayment_interval_encoded'] = le.fit_transform(df['repayment_interval'])

# Define features and target for prediction
# Features selected based on relevance to funded_amount
features = ['loan_amount', 'term_in_months', 'lender_count', 'sector_encoded', 'country_encoded', 'repayment_interval_encoded']
X = df[features]
y = df['funded_amount']

# Split data into training and testing sets
# 80% train, 20% test for robust evaluation
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Train Random Forest Regressor model
# Random Forest is chosen for its ability to handle non-linear relationships and feature interactions
rf_model = RandomForestRegressor(n_estimators=100, random_state=42)
rf_model.fit(X_train, y_train)

# Predict on test set and evaluate model performance
y_pred = rf_model.predict(X_test)
mse = mean_squared_error(y_test, y_pred)
r2 = r2_score(y_test, y_pred)

# Visualize feature importance to understand key predictors
feature_importance = pd.Series(rf_model.feature_importances_, index=features).sort_values(ascending=False)
plt.figure(figsize=(8, 6))
feature_importance.plot(kind='bar')
plt.title('Feature Importance in Predicting Funded Amount')
plt.xlabel('Features')
plt.ylabel('Importance')
plt.tight_layout()
plt.savefig('feature_importance.png')  # Save for presentation
plt.close()

# Print key results for presentation
print("\nKey Results for Presentation:")
print(f"1. Model Performance: R-squared = {r2:.2f}, MSE = {mse:.2f}")
print(f"2. Top Feature: {feature_importance.index[0]} with importance {feature_importance.iloc[0]:.3f}")
print("3. Feature importance plot saved as 'feature_importance.png'")



#Linear Regression Model
linear_model = LinearRegression()
linear_model.fit(X_train, y_train)

# Make predictions
y_pred = linear_model.predict(X_test)

# Evaluate the model
mseLR = mean_squared_error(y_test, y_pred)
r2LR = r2_score(y_test, y_pred)

print("\n Linear Regression Model Values:")
print(f"Mean Squared Error: {mseLR:.2f}")
print(f"R-squared Score: {r2LR:.2f}")







#Decision Tree Model
decision_tree_model = DecisionTreeRegressor(random_state=42, max_depth=5)
decision_tree_model.fit(X_train, y_train)

# Make predictions
y_pred = decision_tree_model.predict(X_test)

# Evaluate the model
mseDT = mean_squared_error(y_test, y_pred)
r2DT = r2_score(y_test, y_pred)

print("\nDecision Tree Regressor Model Values:")
print(f"Mean Squared Error: {mseDT:.2f}")
print(f"R-squared Score: {r2DT:.2f}")






df.head()









df['date'] = pd.to_datetime(df['date'])
df = df.set_index('date')



# Visualize the time series
plt.figure(figsize=(10,5))
ts.plot(title="Weekly Funded Amount after Cleaning")
plt.ylabel("Funded Amount")
plt.show()




























# Check for stationarity
print("\nAugmented Dickey-Fuller test on original time series:")
result = adfuller(ts.dropna())
print("ADF Statistic:", result[0])
print("p-value:", result[1])

# Apply differencing and check stationarity again
ts_diff = ts.diff().diff().dropna()
print("\nAugmented Dickey-Fuller test on twice-differenced time series:")
result = adfuller(ts_diff)
print("ADF Statistic after differencing:", result[0])
print("p-value:", result[1])


























# Plot ACF and PACF
print("\nACF and PACF plots for identifying ARIMA order:")
plot_acf(ts_diff, lags=20)
plt.title("ACF - AutoCorrelation (Twice-Differenced)")
plt.show()

plot_pacf(ts_diff, lags=20)
plt.title("PACF - Partial AutoCorrelation (Twice-Differenced)")
plt.show()






















# Split data
train = ts[:-6]
test = ts[-6:]
print(f"\nTime series split: Train size = {len(train)}, Test size = {len(test)}")
print("\nTraining ARIMA(1,2,0) model:")
try:
    model = ARIMA(ts, order=(1,2,0))
    model_fit = model.fit()
    print(model_fit.summary())
except Exception as e:
    print(f"Error during ARIMA model fitting: {e}")
    model_fit = None
if model_fit is not None:
    # Forecast
    print("\nGenerating forecasts:")
    try:
        forecast = model_fit.predict(start=test.index[0], end=test.index[-1])
        # Visualize forecast
        plt.figure(figsize=(10,5))
        plt.plot(train.index, train, label='Train')
        plt.plot(test.index, test, label='Test', marker='o')
        plt.plot(forecast.index, forecast, label='Forecast', marker='x')
        plt.title('ARIMA(1,2,0) Forecast vs Actual')
        plt.xlabel('Date')
        plt.ylabel('Funded Amount')
        plt.legend()
        plt.show()







        # Evaluate forecast
        mae = mean_absolute_error(test, forecast)
        rmse = np.sqrt(mean_squared_error(test, forecast))
        print(f"\nForecast Evaluation Metrics:")
        print(f"MAE: {mae:.2f}")
        print(f"RMSE: {rmse:.2f}")
        # Calculate relative error and approximate accuracy
        mean_funding = ts.mean()
        relative_error = (mae / mean_funding) * 100
        approx_accuracy = 100 - relative_error
        print(f"Relative Error to Mean: {relative_error:.2f}%")
        print(f"Approximate Accuracy: {approx_accuracy:.2f}%")
        # Visualize fitted values
        fitted = model_fit.fittedvalues
        plt.figure(figsize=(10, 6))
        plt.plot(ts.index, ts, label='Original (Weekly)', color='blue')
        plt.plot(fitted.index, fitted, label='Fitted Values', color='red')
        plt.title(f'ARIMA(1,2,0) Model – Weekly Funded Amount (Fitted)')
        plt.xlabel('Date')
        plt.ylabel('Funded Amount')
        plt.legend()
        plt.grid(True)
        plt.show()

    except Exception as e:
        print(f"Error during forecasting or evaluation: {e}")